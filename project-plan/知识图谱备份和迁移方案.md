# 知识图谱备份和迁移方案

## 📋 概述

本文档详细说明如何备份、迁移和恢复Memory工具的知识图谱数据，确保项目知识的安全性和连续性。

## 🎯 目标

- 建立知识图谱的备份机制
- 实现跨设备的数据迁移
- 确保项目知识的持久化存储
- 提供数据恢复和同步方案

## 📊 当前知识图谱状态

### 实体统计
- **总实体数**: 6个
- **实体类型**: 团队、项目、AI助手、开发项目、技术问题
- **关系数量**: 5个
- **最后更新**: 2025年09月28日

### 数据完整性
- ✅ 实体信息完整
- ✅ 关系映射正确
- ✅ 观察记录详细
- ✅ 类型分类清晰

## 🔄 备份策略

### 方案1: 完整图谱导出 (推荐)

#### 1.1 导出命令
```bash
# 使用MCP工具导出完整图谱
echo '{"jsonrpc": "2.0", "id": 1, "method": "tools/call", "params": {"name": "read_graph", "arguments": {}}}' | npx -y @modelcontextprotocol/server-memory > knowledge_graph_backup.json
```

#### 1.2 备份文件格式
```json
{
  "entities": [
    {
      "type": "entity",
      "name": "实体名称",
      "entityType": "实体类型",
      "observations": ["观察1", "观察2"]
    }
  ],
  "relations": [
    {
      "type": "relation",
      "from": "源实体",
      "to": "目标实体",
      "relationType": "关系类型"
    }
  ],
  "metadata": {
    "exportDate": "2025-09-28",
    "version": "v2.1.0",
    "totalEntities": 6,
    "totalRelations": 5
  }
}
```

### 方案2: 增量备份

#### 2.1 定期备份脚本
```bash
#!/bin/bash
# backup_memory.sh

DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="./memory_backups"
BACKUP_FILE="$BACKUP_DIR/knowledge_graph_$DATE.json"

mkdir -p $BACKUP_DIR

echo "开始备份知识图谱..."
echo '{"jsonrpc": "2.0", "id": 1, "method": "tools/call", "params": {"name": "read_graph", "arguments": {}}}' | npx -y @modelcontextprotocol/server-memory > $BACKUP_FILE

echo "备份完成: $BACKUP_FILE"
echo "文件大小: $(du -h $BACKUP_FILE | cut -f1)"
```

#### 2.2 自动备份计划
```bash
# 添加到crontab (每天备份一次)
0 2 * * * /path/to/backup_memory.sh
```

## 🚀 迁移方案

### 方案1: 直接重建 (简单)

#### 1.1 新设备配置
1. 安装Memory工具
2. 配置Cursor MCP
3. 使用配置指南重建知识图谱

#### 1.2 重建脚本
```bash
#!/bin/bash
# rebuild_memory.sh

echo "开始重建知识图谱..."

# 创建核心实体
echo "创建实体..."
echo '{"jsonrpc": "2.0", "id": 1, "method": "tools/call", "params": {"name": "create_entities", "arguments": {"entities": [{"name": "掼蛋计分开发团队", "entityType": "团队", "observations": ["负责掼蛋小程序开发", "使用Cursor IDE", "配置MCP工具"]}]}}}' | npx -y @modelcontextprotocol/server-memory

# 创建关系
echo "创建关系..."
echo '{"jsonrpc": "2.0", "id": 2, "method": "tools/call", "params": {"name": "create_relations", "arguments": {"relations": [{"from": "掼蛋计分开发团队", "to": "掼蛋小程序", "relationType": "开发"}]}}}' | npx -y @modelcontextprotocol/server-memory

echo "重建完成！"
```

### 方案2: 数据导入 (高级)

#### 2.1 导入脚本
```bash
#!/bin/bash
# import_memory.sh

BACKUP_FILE=$1

if [ -z "$BACKUP_FILE" ]; then
    echo "用法: $0 <backup_file.json>"
    exit 1
fi

echo "开始导入知识图谱: $BACKUP_FILE"

# 解析备份文件并重建
python3 -c "
import json
import subprocess
import sys

def call_memory_tool(method, params):
    cmd = f'echo \'{{\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"tools/call\", \"params\": {{\"name\": \"{method}\", \"arguments\": {json.dumps(params)}}}}}\' | npx -y @modelcontextprotocol/server-memory'
    result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
    return result.stdout

# 读取备份文件
with open('$BACKUP_FILE', 'r') as f:
    data = json.load(f)

# 重建实体
if 'entities' in data:
    entities = []
    for entity in data['entities']:
        entities.append({
            'name': entity['name'],
            'entityType': entity['entityType'],
            'observations': entity['observations']
        })
    
    call_memory_tool('create_entities', {'entities': entities})
    print(f'已导入 {len(entities)} 个实体')

# 重建关系
if 'relations' in data:
    relations = []
    for relation in data['relations']:
        relations.append({
            'from': relation['from'],
            'to': relation['to'],
            'relationType': relation['relationType']
        })
    
    call_memory_tool('create_relations', {'relations': relations})
    print(f'已导入 {len(relations)} 个关系')

print('导入完成！')
"
```

## 🔍 验证和测试

### 验证脚本
```bash
#!/bin/bash
# verify_memory.sh

echo "验证知识图谱完整性..."

# 检查实体数量
echo "检查实体数量..."
ENTITY_COUNT=$(echo '{"jsonrpc": "2.0", "id": 1, "method": "tools/call", "params": {"name": "read_graph", "arguments": {}}}' | npx -y @modelcontextprotocol/server-memory | jq '.result.content[0].text' | jq '.entities | length')

echo "实体数量: $ENTITY_COUNT"

# 检查关系数量
RELATION_COUNT=$(echo '{"jsonrpc": "2.0", "id": 1, "method": "tools/call", "params": {"name": "read_graph", "arguments": {}}}' | npx -y @modelcontextprotocol/server-memory | jq '.result.content[0].text' | jq '.relations | length')

echo "关系数量: $RELATION_COUNT"

# 搜索测试
echo "搜索测试..."
SEARCH_RESULT=$(echo '{"jsonrpc": "2.0", "id": 1, "method": "tools/call", "params": {"name": "search_nodes", "arguments": {"query": "掼蛋"}}}' | npx -y @modelcontextprotocol/server-memory)

echo "搜索结果: $SEARCH_RESULT"

echo "验证完成！"
```

## 📁 文件管理

### 备份文件命名规范
```
knowledge_graph_YYYYMMDD_HHMMSS.json
```

### 目录结构
```
project-plan/
├── Memory工具配置指南.md
├── 知识图谱备份和迁移方案.md
└── memory_backups/
    ├── knowledge_graph_20250928_143000.json
    ├── knowledge_graph_20250928_150000.json
    └── knowledge_graph_20250928_160000.json
```

### 版本控制
- 将备份文件加入Git版本控制
- 定期提交备份更新
- 标记重要版本节点

## 🚨 故障恢复

### 数据丢失恢复
1. **识别问题**: 检查Memory工具状态
2. **选择备份**: 选择最近的完整备份
3. **恢复数据**: 使用导入脚本恢复
4. **验证完整性**: 运行验证脚本
5. **更新配置**: 确保配置正确

### 部分数据损坏
1. **导出当前数据**: 获取损坏后的状态
2. **对比备份**: 识别缺失的数据
3. **增量恢复**: 只恢复缺失部分
4. **验证修复**: 确认数据完整性

## 📊 监控和维护

### 定期检查
- **每周**: 检查备份文件完整性
- **每月**: 验证知识图谱数据一致性
- **每季度**: 更新备份策略和脚本

### 性能监控
- **存储空间**: 监控备份文件大小
- **响应时间**: 检查Memory工具性能
- **错误日志**: 分析MCP连接问题

## 🔧 工具和脚本

### 必需工具
- **Node.js**: Memory工具运行环境
- **jq**: JSON数据处理
- **curl**: HTTP请求工具
- **Python3**: 高级数据处理脚本

### 可选工具
- **Git**: 版本控制
- **Cron**: 定时任务
- **Docker**: 容器化部署

## 📝 最佳实践

### 备份策略
1. **3-2-1规则**: 3份备份，2种介质，1份异地
2. **定期测试**: 定期验证备份可恢复性
3. **版本标记**: 重要节点创建标记备份

### 迁移策略
1. **分步迁移**: 先迁移核心数据，再迁移扩展数据
2. **验证优先**: 每步都进行验证
3. **回滚准备**: 准备回滚方案

### 维护策略
1. **自动化**: 尽可能自动化备份和验证
2. **文档化**: 记录所有操作和配置
3. **监控化**: 建立监控和告警机制

## 📞 技术支持

### 问题排查
1. **检查日志**: 查看Cursor和MCP日志
2. **验证配置**: 确认配置文件正确
3. **测试连接**: 验证MCP服务器状态

### 联系支持
- **Maius AI助手**: 提供技术支持和问题诊断
- **项目文档**: 参考配置指南和故障排除
- **社区支持**: MCP官方社区和文档

---

**最后更新**: 2025年09月28日  
**负责人**: 掼蛋计分开发团队  
**版本**: v2.1.0  
**状态**: 生产就绪



