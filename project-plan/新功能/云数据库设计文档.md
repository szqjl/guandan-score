# 掼蛋计分小程序 - 云数据库设计文档

**设计时间**：2025-09-27  
**设计目标**：支持多人实时计分功能  
**技术栈**：微信云开发 - 云数据库  

---

## 📋 **设计原则**

### **1. 成本优化原则**
- **去规范化设计** - 减少关联查询，降低数据库操作次数
- **数据冗余存储** - 避免复杂的JOIN操作
- **批量操作** - 减少频繁的读写操作

### **2. 性能优化原则**
- **单表查询** - 大部分查询只需要访问一张表
- **索引优化** - 为常用查询字段建立索引
- **数据压缩** - 合理的数据结构设计

### **3. 扩展性原则**
- **字段预留** - 为未来功能预留字段
- **版本兼容** - 支持数据结构升级
- **分表策略** - 为大数据量做准备

---

## 🗄️ **核心数据表设计**

### **1. 房间表 (rooms)**

**用途**：存储房间信息和游戏状态

```javascript
// 房间表结构
const roomSchema = {
  _id: String,                    // 房间ID（自动生成）
  roomCode: String,               // 6位房间码（用户友好）
  creatorId: String,              // 房主openid
  creatorName: String,            // 房主昵称
  status: String,                 // 房间状态：waiting|playing|finished
  mode: String,                   // 游戏模式：guanda|bashu
  robotStrategy: String,          // 机器人策略：none|default_teammate|robot
  maxRounds: Number,              // 最大轮数
  currentRound: Number,           // 当前轮数
  players: Array,                 // 玩家信息数组
  currentScore: Object,           // 当前比分
  scoreHistory: Array,            // 完整计分历史
  settings: Object,               // 房间设置
  createdAt: Date,                // 创建时间
  updatedAt: Date,                // 更新时间
  finishedAt: Date                // 结束时间
};
```

**详细字段说明**：

```javascript
// players 数组结构
players: [
  {
    seatNo: Number,               // 座位号 1-4
    playerId: String,             // 玩家openid 或 "robot_xxx"
    playerName: String,           // 玩家昵称
    avatar: String,               // 头像URL
    team: String,                 // 队伍：red|blue
    status: String,               // 状态：normal|robot|quit
    joinTime: Date,               // 加入时间
    isOwner: Boolean              // 是否房主
  }
]

// currentScore 对象结构
currentScore: {
  red: Number,                    // 红队总分
  blue: Number,                   // 蓝队总分
  redLevel: String,               // 红队当前等级
  blueLevel: String,              // 蓝队当前等级
  redAAttempts: Number,           // 红队A阶段尝试次数
  blueAAttempts: Number           // 蓝队A阶段尝试次数
}

// scoreHistory 数组结构
scoreHistory: [
  {
    round: Number,                // 轮次
    action: String,               // 操作类型：score|level_up|a_attempt
    team: String,                 // 队伍：red|blue
    points: Number,               // 得分
    newScore: Object,             // 新比分
    newLevel: String,             // 新等级
    description: String,          // 操作描述
    timestamp: Date,              // 操作时间
    operatorId: String            // 操作者ID
  }
]
```

### **2. 用户表 (users)**

**用途**：存储用户基本信息和统计数据

```javascript
// 用户表结构
const userSchema = {
  _openid: String,                // 微信openid（主键）
  nickName: String,               // 昵称
  avatar: String,                 // 头像URL
  totalGames: Number,             // 总游戏场次
  winGames: Number,               // 胜利场次
  totalScore: Number,             // 总得分
  avgScore: Number,               // 平均得分
  mvpCount: Number,               // MVP次数
  lastActiveAt: Date,             // 最后活跃时间
  createdAt: Date,                // 注册时间
  updatedAt: Date                 // 更新时间
};
```

### **3. 游戏记录表 (game_records)**

**用途**：存储详细的游戏记录（可选，用于高级统计）

```javascript
// 游戏记录表结构
const gameRecordSchema = {
  _id: String,                    // 记录ID
  roomId: String,                 // 房间ID
  playerId: String,               // 玩家ID
  gameMode: String,               // 游戏模式
  finalScore: Number,             // 最终得分
  finalLevel: String,             // 最终等级
  isWinner: Boolean,              // 是否胜利
  isMVP: Boolean,                 // 是否MVP
  gameDuration: Number,           // 游戏时长（分钟）
  createdAt: Date,                // 创建时间
  roomData: Object                // 房间数据快照
};
```

---

## 🔗 **表关系设计**

### **关系说明**
```
rooms (1) ←→ (N) game_records
users (1) ←→ (N) game_records
rooms.creatorId → users._openid
rooms.players[].playerId → users._openid
```

### **查询优化**
- **房间详情**：只需查询 rooms 表
- **用户统计**：查询 users 表 + game_records 表聚合
- **历史记录**：查询 game_records 表

---

## 📊 **索引设计**

### **rooms 表索引**
```javascript
// 主要索引
{ "roomCode": 1 }                 // 房间码查询
{ "creatorId": 1 }                // 房主查询
{ "status": 1, "updatedAt": -1 }  // 活跃房间查询
{ "createdAt": -1 }               // 时间排序
```

### **users 表索引**
```javascript
// 主要索引
{ "_openid": 1 }                  // 主键索引
{ "lastActiveAt": -1 }            // 活跃用户查询
{ "totalGames": -1 }              // 游戏场次排序
```

### **game_records 表索引**
```javascript
// 主要索引
{ "playerId": 1, "createdAt": -1 } // 玩家历史查询
{ "roomId": 1 }                   // 房间记录查询
{ "gameMode": 1, "createdAt": -1 } // 模式统计查询
```

---

## 💾 **数据存储策略**

### **1. 数据生命周期**
```
rooms 表：
├── 活跃房间：实时更新
├── 已完成房间：保留30天
└── 过期房间：定期清理

users 表：
├── 活跃用户：实时更新
└── 长期存储：永久保留

game_records 表：
├── 近期记录：实时查询
└── 历史记录：定期归档
```

### **2. 数据同步策略**
```
实时同步：
├── 房间状态变化
├── 比分更新
└── 玩家加入/离开

批量同步：
├── 用户统计数据
├── 游戏记录统计
└── 历史数据分析
```

---

## 🚀 **云函数接口设计**

### **房间相关云函数**
```javascript
// createRoom - 创建房间
exports.main = async (event, context) => {
  // 生成房间码
  // 创建房间记录
  // 返回房间信息
};

// joinRoom - 加入房间
exports.main = async (event, context) => {
  // 验证房间码
  // 检查房间状态
  // 添加玩家信息
};

// updateScore - 更新比分
exports.main = async (event, context) => {
  // 验证权限
  // 更新比分
  // 记录历史
  // 返回新状态
};

// getRoomDetail - 获取房间详情
exports.main = async (event, context) => {
  // 查询房间信息
  // 返回完整数据
};
```

### **用户相关云函数**
```javascript
// getUserProfile - 获取用户信息
exports.main = async (event, context) => {
  // 查询用户基本信息
  // 计算统计数据
  // 返回用户资料
};

// updateUserStats - 更新用户统计
exports.main = async (event, context) => {
  // 更新游戏统计
  // 计算胜率等数据
};
```

---

## 💰 **成本估算**

### **数据库操作成本**
```
单局游戏（4人，20轮）：
├── 房间创建：1次写入
├── 玩家加入：4次写入
├── 比分更新：20次写入
├── 房间查询：50次读取
└── 总计：约75次操作

预估成本：
├── 数据库写入：25次 × 0.01元 = 0.25元
├── 数据库读取：50次 × 0.005元 = 0.25元
└── 单局成本：约0.5元
```

### **优化策略**
- **批量操作**：减少写入次数
- **数据缓存**：减少读取次数
- **智能同步**：只在必要时同步
- **定期清理**：清理过期数据

---

## 🎯 **实施计划**

### **第一阶段：基础表结构**
1. 创建 rooms 表
2. 创建 users 表
3. 设置基础索引
4. 编写基础云函数

### **第二阶段：功能完善**
1. 完善数据验证
2. 添加错误处理
3. 优化查询性能
4. 添加数据备份

### **第三阶段：高级功能**
1. 添加 game_records 表
2. 实现数据统计
3. 添加数据归档
4. 性能监控

---

**设计状态**：初稿完成  
**最后更新**：2025-09-27  
**下次更新**：实施后优化

---

## ✅ **设计完成！**

这个数据库设计基于我们的需求讨论，采用了成本优化和性能优化的策略。接下来我们可以开始具体的实施工作！
